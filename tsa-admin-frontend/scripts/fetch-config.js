#!/usr/bin/env node

/**
 * Build-time SSM Configuration Fetcher
 * Fetches API endpoints from AWS SSM Parameter Store and generates static config
 * Run this during build process to get the latest infrastructure URLs
 */

const { SSMClient, GetParametersCommand } = require('@aws-sdk/client-ssm');
const fs = require('fs');
const path = require('path');

// Configuration
const REGION = 'us-east-2';
const OUTPUT_FILE = path.join(__dirname, '../.env.local');

// Detect environment
function getEnvironment() {
  const env = process.env.NEXT_PUBLIC_ENVIRONMENT || process.env.NODE_ENV;
  if (env === 'production') return 'prod';
  if (env === 'staging') return 'staging';
  return 'dev';
}

// No fallback configuration - require explicit environment setup

async function fetchSSMParameters(stage) {
  console.log(`ğŸ” Fetching SSM parameters for stage: ${stage}`);
  
  const ssmClient = new SSMClient({ region: REGION });
  
  const parameterNames = [
    `/tsa-admin/${stage}/api-urls/adminApi`,
    `/tsa-coach/${stage}/api-urls/coachApi`, 
    `/tsa-coach/${stage}/api-urls/passwordlessAuth`,
  ];

  try {
    const command = new GetParametersCommand({
      Names: parameterNames,
      WithDecryption: false,
    });

    const response = await ssmClient.send(command);
    
    const config = {};
    const found = [];
    const missing = [];

    response.Parameters?.forEach((param) => {
      const pathParts = param.Name.split('/');
      const key = pathParts[pathParts.length - 1]; // Get last part (adminApi, coachApi, etc.)
      
      // Map parameter names to config keys
      if (key === 'passwordlessAuth') {
        config['passwordlessAuth'] = param.Value;
      } else {
        config[key] = param.Value;
      }
      
      found.push(param.Name);
    });

    // Check for missing parameters
    parameterNames.forEach(name => {
      if (!response.Parameters?.find(p => p.Name === name)) {
        missing.push(name);
      }
    });

    if (missing.length > 0) {
      console.warn(`âš ï¸  Missing SSM parameters: ${missing.join(', ')}`);
    }

    console.log(`âœ… Found ${found.length}/${parameterNames.length} SSM parameters`);
    
    return {
      success: true,
      config,
      found,
      missing,
    };

  } catch (error) {
    console.error('âŒ Failed to fetch SSM parameters:', error.message);
    return {
      success: false,
      error: error.message,
      config: {},
      found: [],
      missing: parameterNames,
    };
  }
}

async function generateConfig() {
  const stage = getEnvironment();
  console.log(`ğŸš€ Generating configuration for environment: ${stage}`);

  // Try to fetch from SSM first
  const ssmResult = await fetchSSMParameters(stage);
  
  // Start with placeholder configuration for missing APIs
  let finalConfig = {
    adminApi: 'https://api-placeholder.tsa.dev/admin',
    coachApi: 'https://api-placeholder.tsa.dev/coach',
    passwordlessAuth: 'https://hcp1htntxf.execute-api.us-east-2.amazonaws.com/api'
  };
  
  // Use SSM values if available
  if (ssmResult.success && Object.keys(ssmResult.config).length > 0) {
    finalConfig = { ...finalConfig, ...ssmResult.config };
    console.log('âœ… Using SSM configuration where available');
  } else {
    console.warn('âš ï¸  SSM configuration unavailable, using placeholder URLs');
    console.warn('ğŸ’¡ Deploy infrastructure to get real API endpoints');
  }

  // Override with environment variables (highest priority)
  if (process.env.NEXT_PUBLIC_ADMIN_API_URL) {
    finalConfig.adminApi = process.env.NEXT_PUBLIC_ADMIN_API_URL;
    console.log('ğŸ”§ Admin API URL overridden by environment variable');
  }
  
  if (process.env.NEXT_PUBLIC_COACH_API_URL) {
    finalConfig.coachApi = process.env.NEXT_PUBLIC_COACH_API_URL;
    console.log('ğŸ”§ Coach API URL overridden by environment variable');
  }
  
  if (process.env.NEXT_PUBLIC_PASSWORDLESS_AUTH_URL) {
    finalConfig.passwordlessAuth = process.env.NEXT_PUBLIC_PASSWORDLESS_AUTH_URL;
    console.log('ğŸ”§ Passwordless Auth URL overridden by environment variable');
  }

  // Generate .env.local file
  const envContent = [
    `# Auto-generated environment file - ${new Date().toISOString()}`,
    `# Generated by fetch-config.js from SSM parameters`,
    ``,
    `# API Endpoints`,
    `NEXT_PUBLIC_TSA_ADMIN_API_URL=${finalConfig.adminApi}`,
    `NEXT_PUBLIC_TSA_COACH_API_URL=${finalConfig.coachApi}`,
    `NEXT_PUBLIC_TSA_AUTH_API_URL=${finalConfig.passwordlessAuth}`,
    `NEXT_PUBLIC_PASSWORDLESS_AUTH_URL=${finalConfig.passwordlessAuth}`,
    ``,
    `# Environment`,
    `NEXT_PUBLIC_ENVIRONMENT=${stage === 'prod' ? 'production' : stage === 'staging' ? 'staging' : 'development'}`,
    ``
  ].join('\n');

  // Write .env.local file
  fs.writeFileSync(OUTPUT_FILE, envContent, 'utf8');
  
  console.log(`âœ… Environment file written to: ${OUTPUT_FILE}`);
  console.log('ğŸ“‹ Final configuration:');
  console.log(JSON.stringify(finalConfig, null, 2));
  
  return finalConfig;
}

// Validation function
function validateConfig(config) {
  const required = ['passwordlessAuth'];
  const missing = required.filter(key => !config[key]);
  
  if (missing.length > 0) {
    console.error(`âŒ Missing required configuration: ${missing.join(', ')}`);
    console.error('ğŸ”§ Deploy infrastructure: cd tsa-infrastructure && cdk deploy tsa-infra-auth-dev');
    process.exit(1);
  }
  
  // Validate URL format for existing endpoints
  for (const [key, url] of Object.entries(config)) {
    if (url && url !== 'NOT_FOUND') {
      try {
        new URL(url);
      } catch (error) {
        console.error(`âŒ Invalid URL for ${key}: ${url}`);
        process.exit(1);
      }
    }
  }
  
  // Log warnings for missing optional APIs
  const optional = ['adminApi', 'coachApi'];
  const missingOptional = optional.filter(key => !config[key] || config[key] === 'NOT_FOUND');
  
  if (missingOptional.length > 0) {
    console.warn(`âš ï¸  Optional APIs not deployed: ${missingOptional.join(', ')}`);
    console.warn('ğŸ’¡ These will use placeholder URLs until deployed');
  }
  
  console.log('âœ… Configuration validation passed');
}

// Main execution
async function main() {
  try {
    const config = await generateConfig();
    validateConfig(config);
    
    console.log('\nğŸ‰ Configuration generation completed successfully!');
    console.log('ğŸ’¡ This config will be used by the frontend application');
    
    // Display next steps
    console.log('\nğŸ“‹ Next steps:');
    console.log('1. Build the frontend: npm run build');
    console.log('2. Start the application: npm start');
    console.log('3. The app will use the generated configuration');
    
  } catch (error) {
    console.error('âŒ Configuration generation failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { generateConfig, validateConfig }; 